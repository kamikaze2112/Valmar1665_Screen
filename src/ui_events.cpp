// This file was generated by SquareLine Studio
// SquareLine Studio version: SquareLine Studio 1.5.3
// LVGL version: 9.2.2
// Project name: Valmar_Screen
#include <Arduino.h>
#include "globals.h"
#include "ui.h"
#include "comms.h"
#include "prefs.h"
#include "WAVPlayer.h"
#include <cstdlib>
#include "errorHandler.h"

int tempWidth = 600;
int tempRuns = 8;
int tempBrightness = 200;

void calibrationInput(lv_event_t * e)
{
	const char *text = lv_textarea_get_text(ui_txtCalWeight);
	
	if (text && strlen(text) > 0) {
		calibrationWeight = atof(text);
		Serial.printf("Calibration Weight %.3f\n", calibrationWeight);
		outgoingData.calcSeedPerRev = true;
		calibrationMode = false;
		lv_textarea_set_text(uic_txtCalWeight, "");
	}
}

void calSwitchToggle(lv_event_t * e)
{
	if (lv_obj_has_state(ui_swCalibrate, LV_STATE_CHECKED)) {
		calibrationMode = true;
		
	} else {
		calibrationMode = false;
		lv_textarea_set_text(ui_txtCalWeight, "");
	}

	outgoingData.calibrationMode = calibrationMode;
	DBG_PRINT("Calibration mode toggled to: ");
    DBG_PRINTLN(calibrationMode ? "ON" : "OFF");
}

void rateChange(lv_event_t * e)
{
	int seedingRateRawValue = lv_spinbox_get_value(ui_spinboxRate);
	seedingRate = seedingRateRawValue / 10.0f;

	lv_obj_set_style_border_color(ui_spinboxRate, lv_color_hex(0xffb81d), LV_PART_CURSOR | LV_STATE_DEFAULT);
	lastChangeTime = millis();
	savePending = true;

	Serial.printf("Seeding Rate: %.1f\n", seedingRate);
}

void backlightControl(lv_event_t * e)
{
	int backlightVal = lv_slider_get_value(ui_sldBrightness);
	ledcWrite(0, backlightVal);
}
void initReset(lv_event_t * e)
{
	//Send reset command to the rate controller

	outgoingData.reset = true;

	for (int i = 0; i < 3; i++) {
	outgoingData.type = PACKET_TYPE_DATA;
	esp_now_send(controllerAddress, (uint8_t *)&outgoingData, sizeof(outgoingData));                
	delay(5);
	}

	clearPrefs();
	delay(100);
	clearComms();
	delay(100);
	DBG_PRINTLN("Reset complete.  Rebooting...");

	ESP.restart();

}

void motorTest(lv_event_t * e)
{
	if (lv_obj_has_state(ui_swMotorTest, LV_STATE_CHECKED)) {
		motorTestSwitch = true;	
	} else {
		motorTestSwitch = false;
	}

	DBG_PRINT("motorTestSwitch: ");
    DBG_PRINTLN(motorTestSwitch);

}

void motorTestUpdatePWM(lv_event_t * e)
{
	motorTestPWM = lv_arc_get_value(ui_arcMotorPWM);

	DBG_PRINT("motorTestPWM: ");
    DBG_PRINTLN(motorTestPWM);
}

void speedTestUpdateSpeed(lv_event_t * e)
{
	speedTestSpeed = lv_arc_get_value(ui_arcTestSpeed) / 10.0f;

	char testSpeedBuf[10];
  
  	snprintf(testSpeedBuf, sizeof(testSpeedBuf), "%.1f", speedTestSpeed);

	lv_label_set_text(ui_lblTestSpeed, testSpeedBuf);

	DBG_PRINT("speedTestSpeed: ");
    DBG_PRINTLN(speedTestSpeed);
}

void speedTest(lv_event_t * e)
{
	if (lv_obj_has_state(ui_swSpeedTest, LV_STATE_CHECKED)) {
		speedTestSwitch = true;
		speedTestSpeed = lv_arc_get_value(ui_arcTestSpeed) / 10.0f;
		lv_label_set_text(ui_lblMPHBox, "!! MPH !!");
		lv_obj_set_style_text_color(ui_lblSpeed, lv_color_hex(0xffb81d), LV_PART_MAIN);
	
	} else {
		speedTestSwitch = false;
		lv_label_set_text(ui_lblMPHBox, "MPH");
		lv_obj_set_style_text_color(ui_lblSpeed, lv_color_hex(0xffffff), LV_PART_MAIN);
	}

	DBG_PRINT("speedTestSwitch: ");
    DBG_PRINTLN(speedTestSwitch);
}

void warningAcknowledge(lv_event_t * e) {

	acknowledgeWarning();
}
void stopAcknowlege(lv_event_t * e) {
	
	acknowledgeWarning();
}

void seedSwitchToggle(lv_event_t * e) {
	
}


void seedPerRevManualSet(lv_event_t * e) {

    const char* text = lv_textarea_get_text(ui_txtSeedPerRev);
    float newSeedPerRev = atof(text);

    // Set values in outgoingData
    outgoingData.newSeedPerRev = newSeedPerRev;
    outgoingData.manualSeedUpdate = true;

    // Send via ESP-NOW
    esp_now_send(controllerAddress, (uint8_t *)&outgoingData, sizeof(outgoingData));

	outgoingData.manualSeedUpdate = false;

	lv_textarea_set_text(ui_txtSeedPerRev, "");

}

void pairController(lv_event_t * e)
{
	addPeer(broadcastAddress);
	pairingMode = true;
}

void controllerFirmware(lv_event_t * e)
{
	DBG_PRINTLN("controllerFirmware");

	outgoingData.fwUpdateMode = true;

	for (int i = 0; i < 3; i++) {
	outgoingData.type = PACKET_TYPE_DATA;
	esp_now_send(controllerAddress, (uint8_t *)&outgoingData, sizeof(outgoingData));                
	delay(5);
	Serial.printf("Sent %d, %d times.\n", outgoingData.fwUpdateMode, i + 1);
	}

	outgoingData.fwUpdateMode = false;
}

void saveSettings(lv_event_t * e)
{
	outgoingData.workingWidth = lv_spinbox_get_value(ui_spnWidth) / 10;
	outgoingData.numberOfRuns = lv_spinbox_get_value(ui_spnRuns);
	savePrefs();
}

void resetTextArea(lv_event_t * e)
{
	lv_textarea_set_text(ui_txtSeedPerRev, "");
}

void settingsSnapshot(lv_event_t * e)
{
	tempWidth = lv_spinbox_get_value(ui_spnWidth);
	tempRuns = lv_spinbox_get_value(ui_spnRuns);
	tempBrightness = lv_slider_get_value(ui_sldBrightness);
}

void revertSettings(lv_event_t * e)
{
	lv_spinbox_set_value(ui_spnWidth, tempWidth);
	lv_spinbox_set_value(ui_spnRuns, tempRuns);
	lv_slider_set_value(ui_sldBrightness, tempBrightness, LV_ANIM_OFF);

	lv_obj_set_state(ui_btnSave, LV_STATE_DISABLED, true);

}

void stallProtection(lv_event_t * e)
{
	if (lv_obj_has_state(ui_chkStallProtection, LV_STATE_CHECKED)) {
		outgoingData.stallProtection = true;
	} else {
		outgoingData.stallProtection = false;
	}
}

void updateStallDelay(lv_event_t * e)
{
	outgoingData.stallDelay = (lv_dropdown_get_selected(ui_ddStallDelay) + 2 ) * 100;
}
